"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [7740], {
        7753: function(t, e, n) {
            n.r(e), n.d(e, {
                ScreenInAPISymbol: function() {
                    return u.JC
                },
                page: function() {
                    return I
                }
            });
            var i = n(61049),
                s = n(63788),
                o = n(5096),
                a = n(32979),
                r = n(43757),
                c = n(11717),
                d = n(31191);
            const l = t => `${t}-screenIn`;
            class m {
                constructor(t) {
                    this.animator = t, this.definitions = {}, this.sessionState = {
                        played: new Map,
                        running: new Map
                    }
                }
                _shouldSkipPlayedAnimation(t) {
                    const e = this.sessionState.played.has(t),
                        {
                            playOnce: n,
                            persistOnNav: i
                        } = this.sessionState.played.get(t) || {};
                    return e && (n || i)
                }
                _hideComponent(t) {
                    const e = Array.from(document.querySelectorAll(`#${t}, [id^="${t}__"]`));
                    (null == e ? void 0 : e.length) && e.forEach((t => {
                        t.style.opacity = "0"
                    }))
                }
                unhideComponent(t) {
                    const e = Array.from(document.querySelectorAll(`#${t}, [id^="${t}__"]`));
                    (null == e ? void 0 : e.length) && e.forEach((t => {
                        t.dataset.screenInHide = "done", t.style.opacity = "", t.style.visibility = "inherit"
                    }))
                }
                _addAnimatingClass(t) {
                    const e = document.getElementById(t);
                    if (e) e.classList.add("is-animating"), e.dataset.screenInHide = "done";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        (null == e ? void 0 : e.length) && e.forEach((t => {
                            t.classList.add("is-animating"), t.dataset.screenInHide = "done"
                        }))
                    }
                }
                _removeAnimatingClass(t) {
                    const e = document.getElementById(t);
                    if (e) e.classList.remove("is-animating"), e.dataset.screenInHide = "done";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        (null == e ? void 0 : e.length) && e.forEach((t => {
                            t.classList.remove("is-animating"), t.dataset.screenInHide = "done"
                        }))
                    }
                }
                updateDefinitions(t) {
                    this.definitions = Object.assign(Object.assign({}, this.definitions), t)
                }
                _hideCompBeforeAnimation(t) {
                    const e = l(t);
                    this._shouldSkipPlayedAnimation(e) ? this.unhideComponent(t) : this._hideComponent(t)
                }
                hideBeforeAnimation(t) {
                    this.getCompsToHide(t).forEach((({
                        compId: t
                    }) => {
                        this._hideCompBeforeAnimation(t)
                    }))
                }
                handleRotation(t, e) {
                    t.setAttribute("data-angle", String(e)), t.setAttribute("data-angle-style-location", "style")
                }
                trigger(t = []) {
                    t.reduce(((t, {
                        compId: e
                    }) => {
                        const n = this.definitions[e] || [];
                        return t.concat(n)
                    }), []).forEach((t => {
                        var {
                            action: e
                        } = t, n = (0, d._T)(t, ["action"]);
                        return this.executeAnimation(e, n)
                    }))
                }
                init(t) {
                    this.updateDefinitions(t), this.stopAnimations(), this.hideBeforeAnimation(t)
                }
                addDefinition(t, e, n) {
                    this.handleRotation(e, n), this.updateDefinitions(t)
                }
                executeAnimation(t, {
                    name: e,
                    targetId: n,
                    duration: i = 0,
                    delay: s = 0,
                    playOnce: o = !1,
                    persistOnNav: a = !1,
                    params: r = {}
                }) {
                    const c = l(n);
                    if (this._shouldSkipPlayedAnimation(c)) return void this.unhideComponent(n);
                    const d = {
                            name: e,
                            targetId: n,
                            duration: i,
                            delay: s,
                            params: r
                        },
                        m = {
                            name: "BaseClear",
                            targetId: n,
                            duration: 0,
                            delay: 0,
                            params: {
                                props: "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin",
                                immediateRender: !1
                            }
                        };
                    this.animator.runSequence([{
                        type: "Animation",
                        data: d
                    }, {
                        type: "Animation",
                        data: m
                    }], {
                        callbacks: {
                            onStart: e => {
                                this._addAnimatingClass(n), this.sessionState.running.set(e, {
                                    targetId: n,
                                    action: t
                                })
                            },
                            onComplete: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            },
                            onInterrupt: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            }
                        }
                    }), this.sessionState.played.set(c, {
                        playOnce: o,
                        persistOnNav: a
                    })
                }
                stopAnimations({
                    skipPersistent: t = !0
                } = {}) {
                    this.sessionState.running.forEach((({
                        targetId: e
                    }, n) => {
                        const i = l(e);
                        t && this.sessionState.played.get(i).persistOnNav || this.animator.kill(n, 1)
                    }))
                }
                getAnimationProperties(t) {
                    return this.animator.getAnimationProperties(t)
                }
                getCompsToHide(t) {
                    return Object.entries(t).reduce(((t, [e, n]) => (n.some((({
                        name: t
                    }) => {
                        const e = this.animator.getAnimationProperties(t);
                        return e && e.hideOnStart
                    })) && t.push({
                        compId: e
                    }), t)), [])
                }
                clearState() {
                    this.sessionState.played.clear(), this.sessionState.running.clear()
                }
            }
            var u = n(18562);

            function h({
                manager: t
            }) {
                const e = {};

                function n(e) {
                    const n = e.filter((t => t.visible)).map((t => ({
                        compId: t.id,
                        action: "screenIn"
                    })));
                    t.trigger(n)
                }

                function i(t, i) {
                    const s = e[i] || function(t, e) {
                        const n = {
                            root: null,
                            rootMargin: "0px",
                            threshold: [e]
                        };
                        return new window.IntersectionObserver((function(e, n) {
                            const i = e.map((t => ({
                                visible: t.isIntersecting,
                                ratio: t.intersectionRatio,
                                rect: t.intersectionRect,
                                id: t.target.id
                            })));
                            e.forEach((t => t.isIntersecting && n.unobserve(t.target))), t(i)
                        }), n)
                    }(n, i);
                    s.observe(t), e[i] || (e[i] = s)
                }
                return {
                    start: function(e, n, s) {
                        const o = window.innerHeight;
                        if (n) {
                            const e = n.offsetHeight > o ? .01 : function(t, e) {
                                return t.getAnimationProperties(e).viewportThreshold
                            }(t, s) || 0;
                            i(n, e)
                        }
                    }
                }
            }
            var p = n(8562);
            const g = (0, r.ff)([(0, r.t6)(i.$e, u.u2), (0, r.t6)(i.Wf, u.u2), s.m, o.ZQ, a.C, (0, r.jt)(c.FK)], ((t, e, n, i, s, o) => () => {
                const {
                    compIdToActions: a,
                    compIdToRotations: r
                } = t;
                if (n && !(0, p.yF)(i)) return void Object.keys(a).forEach((async t => {
                    await s.waitForComponentToRender(t), m.prototype.unhideComponent(t)
                }));
                if (!o) return;
                const c = o.getInstance().then((t => {
                    var n, i;
                    const s = null !== (i = null === (n = e.get()) || void 0 === n ? void 0 : n.screenInManager) && void 0 !== i ? i : new m(t);
                    s.init(a);
                    const o = h({
                        manager: s
                    });
                    return e.update((t => Object.assign(Object.assign({}, t), {
                        screenInManager: s,
                        viewport: o
                    }))), {
                        animations: o,
                        screenInManager: s
                    }
                }));
                return async (t, e, i) => {
                    if (!i) return;
                    const {
                        animations: s,
                        screenInManager: o
                    } = await c;
                    if (n) return void o.unhideComponent(t);
                    let d = a[t];
                    if (e !== t) {
                        const t = JSON.parse(JSON.stringify(d));
                        t[0].targetId = e, d = t
                    }
                    o.addDefinition({
                        [e]: d
                    }, i, r[t]), s.start(e, i, d[0].name)
                }
            }));
            var f = n(82627);
            const y = (0, r.ff)([(0, r.t6)(i.$e, u.u2), u.cL, a.C, o.sb, f.O], ((t, e, n, i, s) => {
                let o = () => {};
                return {
                    name: "screenInInit",
                    pageWillMount() {
                        const a = new Set,
                            r = e();
                        if (!r) return;
                        const c = Object.keys(t.compIdToActions || {}),
                            d = () => n.registerToCompLifeCycle(c, u.IA, ((t, e, n) => {
                                a.has(e) ? a.delete(e) : r(t, e, n)
                            }));
                        s["specs.thunderbolt.screenInBeforeHydration"] ? i.then((() => {
                            c.forEach((t => {
                                const e = document.querySelectorAll(`[id^=${t}]`);
                                e.length && e.forEach((e => {
                                    const n = e.id;
                                    r(t, n, e), a.add(n)
                                }))
                            })), o = d()
                        })) : o = d()
                    },
                    pageWillUnmount() {
                        o()
                    }
                }
            }));
            var A = n(59032);
            const I = t => {
                t(u.cL).to(g), t(A.j.PageWillMountHandler, A.j.PageWillUnmountHandler).to(y)
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/group_35.0f6b8dbe.chunk.min.js.map